

module Grammar.Abs where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
data Prog a = Program a [TopDefVar a] [TopDef a] (Blok a)
  deriving (Eq, Ord, Show, Read)

instance Functor Prog where
    fmap f x = case x of
        Program a topdefvars topdefs blok -> Program (f a) (map (fmap f) topdefvars) (map (fmap f) topdefs) (fmap f blok)
data TopDefVar a = VarDef a (Type a) Ident
  deriving (Eq, Ord, Show, Read)

instance Functor TopDefVar where
    fmap f x = case x of
        VarDef a type_ ident -> VarDef (f a) (fmap f type_) ident
data TopDef a = FnDef a (Type a) Ident [Arg a] (Blok a)
  deriving (Eq, Ord, Show, Read)

instance Functor TopDef where
    fmap f x = case x of
        FnDef a type_ ident args blok -> FnDef (f a) (fmap f type_) ident (map (fmap f) args) (fmap f blok)
data Arg a = Argcopy a (Type a) Ident | Argref a (Type a) Ident
  deriving (Eq, Ord, Show, Read)

instance Functor Arg where
    fmap f x = case x of
        Argcopy a type_ ident -> Argcopy (f a) (fmap f type_) ident
        Argref a type_ ident -> Argref (f a) (fmap f type_) ident
data Blok a = Block a [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance Functor Blok where
    fmap f x = case x of
        Block a stmts -> Block (f a) (map (fmap f) stmts)
data Stmt a
    = Empty a
    | Decl a (TopDefVar a)
    | DeclFun a (TopDef a)
    | Ass a (Type a) Ident (Expr a)
    | Incr a (Type a) Ident
    | Decr a (Type a) Ident
    | Ret a (Expr a)
    | Retv a
    | Cond a (Expr a) [Stmt a]
    | CondElse a (Expr a) [Stmt a] [Stmt a]
    | While a (Expr a) [Stmt a]
    | WhileSuspended a (Expr a) [Stmt a]
    | WhileContinued a (Expr a) [Stmt a]
    | SExp a (Expr a)
    | Continue a
    | Break a
    | Print a (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Stmt where
    fmap f x = case x of
        Empty a -> Empty (f a)
        Decl a topdefvar -> Decl (f a) (fmap f topdefvar)
        DeclFun a topdef -> DeclFun (f a) (fmap f topdef)
        Ass a type_ ident expr -> Ass (f a) (fmap f type_) ident (fmap f expr)
        Incr a type_ ident -> Incr (f a) (fmap f type_) ident
        Decr a type_ ident -> Decr (f a) (fmap f type_) ident
        Ret a expr -> Ret (f a) (fmap f expr)
        Retv a -> Retv (f a)
        Cond a expr stmts -> Cond (f a) (fmap f expr) (map (fmap f) stmts)
        CondElse a expr stmts1 stmts2 -> CondElse (f a) (fmap f expr) (map (fmap f) stmts1) (map (fmap f) stmts2)
        While a expr stmts -> While (f a) (fmap f expr) (map (fmap f) stmts)
        WhileSuspended a expr stmts -> WhileSuspended (f a) (fmap f expr) (map (fmap f) stmts)
        WhileContinued a expr stmts -> WhileContinued (f a) (fmap f expr) (map (fmap f) stmts)
        SExp a expr -> SExp (f a) (fmap f expr)
        Continue a -> Continue (f a)
        Break a -> Break (f a)
        Print a expr -> Print (f a) (fmap f expr)
data Type a = Int a | Str a | Bool a | Void a
  deriving (Eq, Ord, Show, Read)

instance Functor Type where
    fmap f x = case x of
        Int a -> Int (f a)
        Str a -> Str (f a)
        Bool a -> Bool (f a)
        Void a -> Void (f a)
data Expr a
    = EVar a (Type a) Ident
    | ELitInt a Integer
    | ELitTrue a
    | ELitFalse a
    | EApp a (Type a) Ident [Expr a]
    | EString a String
    | Neg a (Expr a)
    | Not a (Expr a)
    | EMul a (Expr a) (MulOp a) (Expr a)
    | EAdd a (Expr a) (AddOp a) (Expr a)
    | ERel a (Expr a) (RelOp a) (Expr a)
    | EAnd a (Expr a) (Expr a)
    | EOr a (Expr a) (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Expr where
    fmap f x = case x of
        EVar a type_ ident -> EVar (f a) (fmap f type_) ident
        ELitInt a integer -> ELitInt (f a) integer
        ELitTrue a -> ELitTrue (f a)
        ELitFalse a -> ELitFalse (f a)
        EApp a type_ ident exprs -> EApp (f a) (fmap f type_) ident (map (fmap f) exprs)
        EString a string -> EString (f a) string
        Neg a expr -> Neg (f a) (fmap f expr)
        Not a expr -> Not (f a) (fmap f expr)
        EMul a expr1 mulop expr2 -> EMul (f a) (fmap f expr1) (fmap f mulop) (fmap f expr2)
        EAdd a expr1 addop expr2 -> EAdd (f a) (fmap f expr1) (fmap f addop) (fmap f expr2)
        ERel a expr1 relop expr2 -> ERel (f a) (fmap f expr1) (fmap f relop) (fmap f expr2)
        EAnd a expr1 expr2 -> EAnd (f a) (fmap f expr1) (fmap f expr2)
        EOr a expr1 expr2 -> EOr (f a) (fmap f expr1) (fmap f expr2)
data AddOp a = Plus a | Minus a
  deriving (Eq, Ord, Show, Read)

instance Functor AddOp where
    fmap f x = case x of
        Plus a -> Plus (f a)
        Minus a -> Minus (f a)
data MulOp a = Times a | Div a | Mod a
  deriving (Eq, Ord, Show, Read)

instance Functor MulOp where
    fmap f x = case x of
        Times a -> Times (f a)
        Div a -> Div (f a)
        Mod a -> Mod (f a)
data RelOp a = LTH a | LE a | GTH a | GE a | EQU a | NE a
  deriving (Eq, Ord, Show, Read)

instance Functor RelOp where
    fmap f x = case x of
        LTH a -> LTH (f a)
        LE a -> LE (f a)
        GTH a -> GTH (f a)
        GE a -> GE (f a)
        EQU a -> EQU (f a)
        NE a -> NE (f a)
